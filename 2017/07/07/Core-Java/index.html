<!DOCTYPE html><html lang="zh-CN"><head><!--[if IE]><style>body{display:none;}</style><script>alert('IE浏览器下无法展示效果，请更换浏览器！');var headNode=document.getElementsByTagName('head')[0];var refresh=document.createElement('meta');refresh.setAttribute('http-equiv','Refresh');refresh.setAttribute('Content','0; url=http://outdatedbrowser.com/');headNode.appendChild(refresh);</script><![endif]--><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Dr.Lester"><meta name="description" content="本文分享一些自己对Java类加载、内存分配、Class对象以及反射的理解"><meta name="keywords" content="类加载,内存分配,Class对象,反射"><meta property="og:type" content="article"><meta property="og:title" content="深入Java核心"><meta property="og:url" content="http://GitHubSupervise.io/blog/2017/07/07/Core-Java/index.html"><meta property="og:site_name" content="Godql Code"><meta property="og:description" content="本文分享一些自己对Java类加载、内存分配、Class对象以及反射的理解"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E9%80%92%E5%BD%92%E6%A0%88.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%881.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%BC%95%E7%94%A8.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E6%95%B0%E7%BB%84.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%BE%AA%E7%8E%AF.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E5%8C%BA.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%86%85%E5%AD%98%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"><meta property="og:image" content="http://oo31b5ljj.bkt.clouddn.com/String%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><meta property="og:updated_time" content="2018-05-25T19:25:25.793Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入Java核心"><meta name="twitter:description" content="本文分享一些自己对Java类加载、内存分配、Class对象以及反射的理解"><meta name="twitter:image" content="http://oo31b5ljj.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.png"><link rel="apple-touch-icon" href="/blog//apple-touch-icon.png"><link rel="alternate" href="/atom.xml" title="Godql Code" type="application/atom+xml"><link rel="shortcut icon" href="/blog//favicon.ico"><link href="//cdn.bootcss.com/aos/2.2.0/aos.css" rel="stylesheet"><script src="//cdn.bootcss.com/aos/2.2.0/aos.js"></script><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/blog/css/style.css"><link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="/pages/share/iconfont.css"><link rel="stylesheet" href="/pages/share/spongebob.min.css" type="text/css" media="all"><title>深入Java核心 | Godql Code</title><script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><link href="//cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet"><script>var yiliaConfig={fancybox:!0,isHome:!1,isPost:!0,isArchive:!1,isTag:!1,isCategory:!1,fancybox_js:"//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",search:!0};</script><script>yiliaConfig.jquery_ui=[!1];</script><script>yiliaConfig.rootUrl=/blog/;</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?942836f73232fb2653b75e8e40540295";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}();</script></head></html><body><div id="container"><div class="left-col"><div class="backImg"><img src="/blog//img/yule.png" width="300px" height="330px"></div><div class="intrude-less"><header id="header" class="inner"><a href="/blog/" class="profilepic" data-aos="zoom-in"><img src="/blog//img/Dr.Lester.png"></a><hgroup><h1 class="header-author"><a href="/blog/">Dr.Lester</a></h1></hgroup><p class="header-subtitle">上善若水,虚怀若谷。</p><form id="search-form"><input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search-result"></div><p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p><div id="switch-btn" class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>Menu</li><li>Tags</li><li>About Me</li></ul></div></div><div id="switch-area" class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="/blog//blog/">主页</a></li><li><a href="/blog//blog/archives/">归档</a></li><li><a href="/blog//blog/donate/">留言板</a></li><li><a href="/blog//blog/tags/">标签云</a></li><li><a href="/blog//blog/about/">关于我</a></li></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" href="mailto:googllwebmaster@gmail.com" title="Email"></a> <a class="fa GitHub" href="https://github.com/GitHubSupervise" title="GitHub"></a> <a class="fa QQ" href="http://wpa.qq.com/msgrd?v=3&uin=1025142302&site=qq&menu=yes" title="QQ"></a> <a class="fa RSS" href="/blog/atom.xml" title="RSS"></a></ul><ul class="social"><div style="position:absolute;top:95%;left:50%;margin-left:-30px"><p style="display:block"><a class="donateIcon" href="javascript:void(0)" onmouseout="var qr=document.getElementById(&quot;donate&quot;);qr.style.display=&quot;none&quot" onmouseenter="var qr=document.getElementById(&quot;donate&quot;);qr.style.display=&quot;block&quot">赏</a></p></div></ul></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/AOP/">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Chrome/">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Class对象/">Class对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Hibernate/">Hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/IOC/">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Intellij-IDEA/">Intellij IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Struts/">Struts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/交互/">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/内存分配/">内存分配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/内网/">内网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/反射/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/外网/">外网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/客户端/">客户端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/工作法/">工作法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/思维导图/">思维导图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数值/">数值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/电商/">电商</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/秒杀系统/">秒杀系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/类加载/">类加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/精度/">精度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/读书/">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/调试/">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/资源/">资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/远程桌面/">远程桌面</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/高并发/">高并发</a></li></ul></div></section><section class="switch-part switch-part3"><div id="js-aboutme">此地只专注于技术</div></section></div></div></header><div id="donate"><img id="multipay" src="https://www.godql.com/blog/img/multipay.png" width="250px" alt="Dr.Lester Multipay"><div class="triangle"></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bubbly-bg@0.2.3/dist/bubbly-bg.js"></script><script>var userAgent=window.navigator.userAgent;bubbly({animate:!0,blur:1,bubbleFunc:()=>`hsla(${360*Math.random()}, 100%, 50%, ${.25*Math.random()})`,bubbles:userAgent.match(/AppleWebKit.*Mobile.*/)?20:50,canvas:document.querySelector("#background"),colorStart:"#f6d365",colorStop:"#fda085",compose:"lighter",shadowColor:"#383838"});</script><div class="hide-left-col" title="隐藏侧栏"><i class="fa fa-angle-double-left"></i></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Dr.Lester</a></h1></div><div class="intrude-less"><header id="header" class="inner"><a href="/blog/" class="profilepic" data-aos="zoom-in"><img src="/blog//img/Dr.Lester.png"></a><hgroup><h1 class="header-author"><a href="/blog/" title="回到主页">Dr.Lester</a></h1></hgroup><p class="header-subtitle">上善若水,虚怀若谷。</p><nav class="header-menu"><ul><li><a href="/blog/">主页</a></li><li><a href="/blog/archives/">归档</a></li><li><a href="/blog/donate/">留言板</a></li><li><a href="/blog/tags/">标签云</a></li><li><a href="/blog/about/">关于我</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" target="_blank" href="mailto:googllwebmaster@gmail.com" title="Email"></a> <a class="fa GitHub" target="_blank" href="https://github.com/GitHubSupervise" title="GitHub"></a> <a class="fa QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=1025142302&site=qq&menu=yes" title="QQ"></a> <a class="fa RSS" target="_blank" href="/blog/atom.xml" title="RSS"></a></ul></nav></header></div><link class="menu-list" tags="Tags" friends="Friends" about="About Me"></nav><div class="body-wrap"><article id="post-Core-Java" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/blog/2017/07/07/Core-Java/" class="article-date"><time datetime="2017-07-07T15:50:39.000Z" itemprop="datePublished">2017-07-07</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 class="article-title" itemprop="name">深入Java核心</h1></header><div class="article-info article-info-post"><div class="article-category tagcloud"><a class="article-category-link" href="/blog/categories/Java/">Java</a></div><div class="article-tag tagcloud" style="display:flex;flex-wrap:wrap"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Class对象/">Class对象</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/内存分配/">内存分配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/反射/">反射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/类加载/">类加载</a></li></ul><span class="post-count">总字数5,882</span> <span class="post-count">预计阅读22分钟</span></div><div class="clearfix"></div></div><div class="article-entry" itemprop="articleBody"><a id="more"></a><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><blockquote><p>类加载负责加载编译后的class文件（字节码文件）到JVM当中。</p></blockquote><ul><li>在JRE中，类加载器主要分为以下几种：<ul><li><code>引导类加载器（Bootstrap）</code><ul><li>它本身使用C/C++语言实现的，负责加载Java的核心类库，在jre\lib目录中，当中包括如rt.jar，这些都是Java自带的核心类库，必须由它来完成加载。</li></ul></li><li><code>拓展/扩展类加载器（Extension）</code><ul><li>这个加载器就是由Java语言实现，负责加载jre\lib\ext目录下的类库，这个目录下的类库都是一些扩展类。</li></ul></li><li><code>应用程序/系统类加载器（Application）</code><ul><li>这个类加载器同样使用Java语言实现，它主要负责加载classpath下面的所有类库，通常我们编写的Java类都是由这个类加载器完成加载。</li></ul></li></ul></li><li>三个类加载器的初始化过程：当程序运行时，首先会初始化引导类加载器，它就负责创建和初始化扩展类加载器，当扩展类加载器完成初始化之后，又负责创建和初始化系统类加载器。</li><li>这些类加载器协同起来完成整个类加载的过程，因此这些类加载器的加载模式是基于“双亲委托模型”。</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.png" alt="双亲委托模型"></li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul><li><p>当我们编写一个Java类时，首先负责加载这个类的加载器是系统类加载器，但是它不会立马就去执行加载，而是先把这个任务交给父加载器（扩展类加载器），而扩展类加载器同样也会将这个任务交给父加载器（引导类加载器），最终当引导类加载器不能去加载这个类的时候（也就是在自己加载职责范围找不到的时候），又会将这个任务交回给子加载器。以此类推，最终我们编写的类都会配置在classpath环境中，所以，这个类的加载任务还是回到系统类加载器来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Word"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 程序的入口的方法，和具体类无关</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test t = <span class="keyword">new</span> Test();	</span><br><span class="line">		t.say();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到当前的类加载器ApplicationClassLoader</span></span><br><span class="line">		ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">		System.out.println(cl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到ApplicationClassLoader的父类加载器ExtensionClassLoader</span></span><br><span class="line">		ClassLoader extCl = cl.getParent();</span><br><span class="line">		System.out.println(extCl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到ExtensionClassLoader的父类加载器BootstrapClassLoader</span></span><br><span class="line">		<span class="comment">// 由于BootstrapClassLoader是用C/C++语言编写的，在java中无法直接使用</span></span><br><span class="line">		<span class="comment">// 所以才会返回一个null</span></span><br><span class="line">		ClassLoader bootCl = extCl.getParent();</span><br><span class="line">		System.out.println(bootCl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个class文件最终加载到jvm之后，就表示类加载这个阶段已经全部完成。接下来就是对整个class文件的内容进行解析和做内存的分配。</p></li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><blockquote><p>当JVM运行起来的时候就会给内存划分空间，那么这块空间称之为运行时数据区。<br>(<code>备注：</code>当一个Java源程序编译成class字节码文件之后，字节码文件里存放的都是二进制的汇编命令，当程序运行的时候，JVM会将这个二进制的命令逐行解释，交给CPU去执行)</p></blockquote><ul><li><p>运行时数据区将划分为以下几块内容：</p><ul><li><code>栈</code><ul><li>每一个线程运行起来的时候就会对应一个栈（线程栈），栈当中存放的数据是被当前线程所独有的。而栈当中存放的是栈帧，当线程调用一个方法的时候，就会形成一个栈帧，并将这个栈帧进行压栈操作，当方法执行完之后就会将这个栈帧进行出栈操作。这个栈帧里面包括（局部变量、操作数栈、指向当前方法对应类的常量池引用、方法的返回地址等信息）。<br>(<code>备注：</code>由于局部变量都是存放在栈中，而每一个线程都对应自己的线程栈，因此局部变量是线程安全的，不会才产生资源共享的情况。)</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E9%80%92%E5%BD%92%E6%A0%88.png" alt="递归栈"></li></ul></li><li><code>本地方法栈</code><ul><li>本地方法栈的机制和栈的机制类似，区别在于，栈是运行Java所实现的方法，而本地方法栈是运行的本地方法(Native Method)。所谓的本地方法指的是在本地jvm中需要调用非Java语言所实现的方法，例如c语言。在JVM的规范中，其实没有强制性要求实现方一定要划分出本地方法栈的和具体的实现，这一部分可以根据实现方具体要求来实现。因此在HotSport虚拟机的实现中就将方法栈和本地方法栈二合为一。</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%881.png" alt="本地方法栈"></li></ul></li><li><code>程序计数器</code><ul><li>程序计数器也可以称之为PC寄存器。它主要用于存放当前程序下一条将要执行的指令地址。CPU会根据这个地址找到对应的指令来执行。通俗的讲就是指令缓存。这个寄存器是有JVM内部实现的，并不是物理概念上的寄存器，但是JVM在实现功能的逻辑上是相同的。</li></ul></li><li><code>堆</code><ul><li>堆内存中主要存放创建的对象以及数组。 堆内存是可以被多个线程所共享的一块区域,因此多个线程栈都可以去访问同一块堆的内存区域。堆里面的每一对象都存放了该实例的实例变量。</li><li>当在方法中定义了一个局部变量，如果这个变量是基本数据类型，那么这个变量的值就直接存放在栈中，如果这个变量是引用数据类型，那么这个对象变量就存放在堆内存中，而栈中存放的是一个指向堆内存中这个对象的首地址。<br>(<code>备注：</code>Java中除了8个基本数据类型以外的所有类型都是引用数据类型)</li><li>引用</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%BC%95%E7%94%A8.png" alt="引用"></li><li>更改</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%94%B9.png" alt="更改"></li><li>数组</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E6%95%B0%E7%BB%84.png" alt="数组"></li><li>循环</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%A0%86%EF%BC%9A%E5%BE%AA%E7%8E%AF.png" alt="循环"></li><li>实例变量和静态变量的区别：<ul><li><code>实例变量：</code>实例变量是随着对象的创建而创建，而实例是存放在堆中，所以实例变量自然也就跟实例一并保存在堆内存。只要创建多少个实例，就会有多少份实例变量。当实例被回收的时候，实例变量也随之而销毁。</li><li><code>静态变量：</code>静态变量也叫类变量，它是在类加载的时候就已经初始化好，并存放在方法区，并且只有一份，所以它是被多个实例所共享的一个变量。</li></ul></li></ul></li><li><p><code>方法区</code></p><ul><li>方法区在JVM中也是一个非常重要的一块内存区域，它和堆一样，是可以被多个线程所共享的一块区域。这个区域中主要存放了每一个加载的class文件信息。<br>在一个class文件中主要包含<code>魔数</code>(代码中出现但没有解释的数字常量或字符串)（用来确定是否是一个class文件）、常量池（常量池在下面会有完整说明）、访问标志（当前的class是类还是接口，是否是抽象类，<br>是否是public修饰，是否使用了<code>final</code>修饰等描述信息…）、字段表集合信息（使用什么访问修饰符、是实例变量还是静态变量，是否用<code>final</code>修饰等描述信息…）、<br>方法表集合信息（访问修饰符，是否静态方法，是否用final修饰，是否用了<code>synchronized</code>修饰，是否是<code>native</code>方法…）等内容。当一个类加载器加载一个class文件的时候，<br>会根据这个class文件的内容创建一个Class对象，而这个Class对象就包括了上述的这些内容。后续要创建这个类的所有实例，都是通过这个Class对象创建出来的。</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="方法区"></li></ul></li><li><p><code>常量池</code></p><ul><li>常量池也是方法区中的一部分，它存放的内容是class文件中最重要的资源，JVM为每一个class对象都维护一个常量池。它主要存储两种类型的常量。<ol><li>字面常量<ul><li>字面常量通常就是在Java中定义的字面量值，如：int i =1,这个1就是字面量；String s = (“abc”)，这个abc就是字面量。或者使用final修饰的常量值等等。</li></ul></li><li>符号引用<ul><li>符号引用主要包括类和接口的完整类名、属性字段的名称和描述符、方法名称和描述符等信息</li></ul></li></ol></li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg" alt="常量池"></li></ul></li></ul></li><li>在Java当中，8个基本数据类型都有对应的包装类型，而大部分包装类型都实现了常量池的技术，除了<code>Double</code>和<code>Float</code>类。<br>(<code>备注说明：</code>在JDK8之后，方法区已经取消，方法区被一个叫MetaSpace，它和堆合并到一起管理)</li><li>内存运行时数据区</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/%E5%86%85%E5%AD%98%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="内存运行时数据区"></li><li><code>扯了好多Java虚拟机的内容，也没讲多深，因为这里主要的目的是为了大家方便理解Java反射机制，下面正式进入正题</code></li></ul><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><blockquote><p>当ClassLoader加载一个class文件到JVM的时候，会自动创建一个该类的Class对象，并且这个对象是唯一的，后续要创建这个类的任何实例，都会根据这个Class对象来创建。因此每当加载一个class文件的时候，都会创建一个与之对应的Class对象。</p></blockquote><ul><li>解析一个类的各个部分，形成一个对象。</li><li><img src="http://oo31b5ljj.bkt.clouddn.com/String%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="String类加载示意图"></li><li><p>外存中的类，加载到内存中，会形成该对象的Class类，例如：String类，加载到内存中，就是StringClass对象。<br>也就是说类是java.lang.Class类的实例对象，而Class是所有类的类<br>对于普通的对象，一般都的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure></li><li><p>既然类都是Class的对象，那么能否像普通对象一样创建呢，当看源码时，是这样写的 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    classLoader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>源码里构造器是私有的，只有JVM可以创建Class的对象，虽然我们不能new一个Class对象，但是可以从已有的类得到一个Class对象，共有三种方式，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名.class  通过获取类的静态成员变量class得到(任何类都有一个隐含的静态成员变量class)</span></span><br><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"><span class="comment">// 对象.getClass</span></span><br><span class="line">Class&lt;?&gt; clazz2 = <span class="keyword">new</span> String().getClass();</span><br><span class="line"><span class="comment">// Class.forName("全量限定名")</span></span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure></li><li><p>(<code>注意：</code>这三种方式都是利用反射获取的都是同一个Class对象，这也叫做String的类类型，也就是描述何为类，一个类都有哪些东西，所以可以通过类类型知道一个类的属性和方法，并可以调用一个类的属性和方法，这就是反射的基础。)</p></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>反射是指<code>在程序的运行期间动态的去操作某个Class对象里面的成员</code>（包括类信息、属性信息、方法信息等元素）。它可以让Java这种静态语言具备一定的动态性。目前大部分的开源框架实现都是基于反射的机制实现。<br>JVM → 类加载 → class文件 → 创建 → Class对象 → 构建类的实例 → instance(实例)；<br>重点在运行时动态的操作Class对象。</p></blockquote><h3 id="反射机制的利与弊"><a href="#反射机制的利与弊" class="headerlink" title="反射机制的利与弊"></a>反射机制的利与弊</h3><p>为何要用反射机制？直接new对象不ok了吗，这就涉及到了动态与静态的概念</p><ul><li>静态编译：在编译时确定类型，绑定对象,即通过。</li><li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有利于降低类之间的藕合。</li><li>优点:<ul><li>可以实现动态创建对象和编译。比如，一个软件，不可能第一个版本就把它设计的很完美，当这个程序编译成功，发布后，当发现某些功能需要更新时，我们不可能要用户把旧版的卸载，再重新安装新的版本。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。<br>一句话总结：<code>运行期类型的判断，动态类加载，动态代理就使用了反射</code></li></ul></li><li>缺点:<br>1.对性能有影响。反射相当于一系列解释操作，通知JVM要做的事情。性能比直接的java代码执行相同的操作要慢很多。<br>2.由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h3 id="反射机制的相关操作"><a href="#反射机制的相关操作" class="headerlink" title="反射机制的相关操作"></a>反射机制的相关操作</h3><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在反射操作之前的第一步，就是要先获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.reflect.bean.People"</span>);</span><br><span class="line"><span class="comment">// 根据Class对象创建一个实例</span></span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure><h4 id="动态操作属性"><a href="#动态操作属性" class="headerlink" title="动态操作属性"></a>动态操作属性</h4><ul><li><p>通过Class对象可以动态的获取和操作类中的属性，属性在JDK中有一个类来进行封装，就是Field,Field提供了一些常用的API方法让我们去访问和操作类中的属性</p><p><code>getField()</code> // 获取所有公开的属性字段（包括继承父类的公有属性）<br><code>getDeclaredField()</code> // 获取本类所有（包括公有和私有，但是不包括父类的）的属性字段（注意：如果要访问和操作私有属性，必须调用setAccessible方法，打开访问开关）<br><code>getFields()</code> // 获取所有公有的属性（包括继承自父类的公有属性）<br><code>getDeclaredFields()</code> // 获取本类所有的属性（包括共有和私有的，但是不包括父类的）<br><code>set()</code> // 给属性赋值，需要传入两个参数，第一个参数是当前类的一个实例，第二个参数是具体要赋予的值<br><code>get()</code> // 获取属性的值，需要传入一个当前类的实例作为参数<br><code>getName()</code> // 获取属性的名称<br><code>getType()</code> // 获取属性的类型<br><code>isAnnotationPresent()</code> // 判断该属性上是否定义了指定的注解，需要传入一个注解的Class对象作为参数<br><code>getAnnotation()</code> // 获取当前属性上的注解对象，需要传入一个注解的Class对象作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 在反射操作之前的第一步，就是要先获取Class对象</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.reflect.bean.People"</span>);</span><br><span class="line">    <span class="comment">// 根据Class对象创建一个实例</span></span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    <span class="comment">// 获取指定的属性</span></span><br><span class="line">    Field f1 = clazz.getField(<span class="string">"userName"</span>);</span><br><span class="line">    <span class="comment">// 获取属性的值,get方法需要传入一个当前类的实例</span></span><br><span class="line">    Object value = f1.get(instance);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射给属性赋值</span></span><br><span class="line">    <span class="comment">// 第一个参数是当前类的实例，第二个参数是要赋予的值</span></span><br><span class="line">    f1.set(instance, <span class="string">"godql"</span>);</span><br><span class="line">    value = f1.get(instance);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个私有的属性</span></span><br><span class="line">    <span class="comment">// 如果需要访问和操作私有的成员，必须打开访问开关</span></span><br><span class="line">    <span class="comment">// 打开访问开关其实就是破坏封装</span></span><br><span class="line">    Field f2 = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">    <span class="comment">// 强制打开访问权限</span></span><br><span class="line">    f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object value2 = f2.get(instance);</span><br><span class="line">    System.out.println(value2);</span><br><span class="line">    f2.set(instance, <span class="number">30</span>);</span><br><span class="line">    value2 = f2.get(instance);</span><br><span class="line">    System.out.println(value2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性的名称</span></span><br><span class="line">    System.out.println(f1.getName());</span><br><span class="line">    System.out.println(f2.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性的类型</span></span><br><span class="line">    System.out.println(f1.getType());</span><br><span class="line">    System.out.println(f2.getType());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有公有的属性(包括继承自父类的公有属性)</span></span><br><span class="line">    Field[] fs1 = clazz.getFields();</span><br><span class="line">    <span class="comment">// 获取本类所有的属性（包括共有和私有的，但是不包括父类的）</span></span><br><span class="line">    Field[] fs2 = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前属性上是否定义了注解</span></span><br><span class="line">    System.out.println(f1.isAnnotationPresent(MyAnno.class));</span><br><span class="line">    ystem.out.println(f2.isAnnotationPresent(MyAnno.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性上定义的注解</span></span><br><span class="line">    MyAnno anno = f1.getAnnotation(MyAnno.class);</span><br><span class="line">    <span class="comment">// 获取注解上的属性值</span></span><br><span class="line">    System.out.println(anno.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态操作方法"><a href="#动态操作方法" class="headerlink" title="动态操作方法"></a>动态操作方法</h4><ul><li><p>对于Class中的方法，API也提供了相应的类来进行封装，就是Method</p><p><code>getMethod()</code> // 获取指定的公共的方法（包括继承自父类公共的），需要传递两个参数，第一个参数是方法名称，第二个参数是一个可变参数，传递的是方法参数的类型<br><code>getMethods()</code> // 获取所有的公共的方法（包括继承父类的公共方法）。<br><code>getDeclaredMethod()</code> // 获取本类中指定的方法（包括私有和共有的，不包括父类的），需要传递两个参数，第一个参数是方法名称，第二个参数是一个可变参数，传递的是方法参数的类型。如果是私有方法，同样需要先打开访问开关(setAccessible(true))。<br><code>getDeclaredMethods()</code> // 获取本地中所有的方法（包括私有和公共的，不包括父类）<br><code>getName()</code> // 获取方法名称<br><code>getReturnType()</code> // 获取方法的返回值类型<br><code>getParameterTypes()</code> // 获取方法中所有的参数类型<br><code>getParameterCount()</code>// 获取方法中参数的总个数<br><code>getParameters()</code> // (JDK1.8新特性)获取方法中所有的参数信息，每一个参数信息都是一个Parameter类的对象。可以通过这个对象获取各个参数的类型以及名称(注意：如果要获取参数名，在编译的时候需要加上一个parameters参数，如：javac -parameters Xxx.java。或者是在开发环境中设置相应的编译选项)。<br><code>invoke()</code> // 回调当前方法,需要传递两个参数，第一个是当前类的实例，第二个是一个可变参数，需要传入调用方法是所需的参数值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"org.demo.reflect.bean.People"</span>);</span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    <span class="comment">// 获取指定的Method</span></span><br><span class="line">    Method m1 = clazz.getMethod(<span class="string">"say"</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 获取方法名</span></span><br><span class="line">    System.out.println(m1.getName());</span><br><span class="line">    <span class="comment">// 获取方法的返回值类型</span></span><br><span class="line">    System.out.println(m1.getReturnType());</span><br><span class="line">    <span class="comment">// 获取方法的所有参数类型</span></span><br><span class="line">    Class&lt;?&gt;[] paramsType = m1.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : paramsType) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数名称（JDK1.8开始支持）</span></span><br><span class="line">    Parameter[] params = m1.getParameters();</span><br><span class="line">    <span class="keyword">for</span> (Parameter p : params) &#123;</span><br><span class="line">        System.out.println(<span class="string">"参数类型:"</span>+p.getType());</span><br><span class="line">        System.out.println(<span class="string">"参数名称:"</span>+p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过当前的方法，获取定义这个方法的类</span></span><br><span class="line">    Class&lt;?&gt; c = m1.getDeclaringClass();</span><br><span class="line">    System.out.println(c.getName());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 方法回调，目的就是通过反射去调用一个方法</span></span><br><span class="line">    m1.invoke(instance, <span class="string">"godql"</span>, <span class="number">21</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态操作构造方法"><a href="#动态操作构造方法" class="headerlink" title="动态操作构造方法"></a>动态操作构造方法</h4><ul><li><p>Constructor是在反射API中用于封装构造方法的一个类，因此通过这个类可以获取构造方法的一些信息，以及通过这个对象来实例化一个类的实例。</p><p><code>getConstructor()</code> // 获取无参并且公共的构造方法<br><code>getDeclaredConstructor()</code> // 获取一个构造方法可以是私有的也可以是公共的，需要传入一个可变参数，就是构造方法的参数类型（注意：如果是私有的，必须先打开访问开关）<br><code>newInstance()</code> // 通过构造方法创建实例，也需要传入一个可变参数，传入的是具体的值<br><code>getConstructors()</code> // 获取所有公共的构造方法，返回的是一个Constructor数组<br><code>getDeclaredConstructors()</code> // 获取所有的构造方法(包括私有和共有的),同样返回的是一个数组<br><code>getParameters()</code> // 获取所有的参数对象，和Method一样<br><code>getParameterTypes()</code> // 获取所有的参数类型，同Method一样</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      </span><br><span class="line">    Class&lt;?&gt; clazz = People.class;</span><br><span class="line">    <span class="comment">// 获取无参的构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; c1 = clazz.getConstructor();</span><br><span class="line">    <span class="comment">// 获取构造方法的名称</span></span><br><span class="line">    System.out.println(c1.getName());</span><br><span class="line">    <span class="comment">// 获取一个私有并且带参数的构造方法</span></span><br><span class="line">    Constructor&lt;?&gt; c2 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以通过构造方法实例化一个对象</span></span><br><span class="line">    <span class="comment">//（注意：如果默认有一个无参并且是公共的构造方法，</span></span><br><span class="line">    <span class="comment">// 那么可以直接使用class.newInstance()方法创建实例，</span></span><br><span class="line">    <span class="comment">// 如果构造方法是私有的，或者是带参数的，就必须先获取</span></span><br><span class="line">    <span class="comment">// Constructor对象，在通过这个对象来创建类实例）</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1.适用于无参并且是公共的构造方法</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      Object instance = clazz.newInstance();</span></span><br><span class="line"><span class="comment">      System.out.println(instance);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.适用于带参数或是私有的构造方法</span></span><br><span class="line">    <span class="comment">// 由于构造方法也可以私有化，所以必须先打开访问开关</span></span><br><span class="line">    c2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object instance = c2.newInstance(<span class="string">"godql"</span>);</span><br><span class="line">    System.out.println(instance);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取所有public修饰的构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[] cons = clazz.getConstructors();</span><br><span class="line">    <span class="comment">// 获取所有构造方法（包括私有的）</span></span><br><span class="line">    Constructor&lt;?&gt;[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Class中的一些API"><a href="#Class中的一些API" class="headerlink" title="Class中的一些API"></a>Class中的一些API</h4><ul><li><p>Class对象本身提供了很多的API方法用于获取和操作Class对象。</p><p><code>getPackage()</code> // 获取当前类所在的包，使用Package对象进行封装，可以从中获取包的信息，例如：包名<br><code>getSimpleName()</code> // 获取当前类的简单类名（不包括包名）<br><code>getName()</code> // 获取当前类的完整类名(包括包名)<br><code>getSuperclass()</code> // 获取当前类的父类，返回的也是一个Class对象<br><code>getInterfaces()</code> // 获取当前类所实现的所有接口，返回的是一个Class数组<br><code>isAnnotationPresent()</code> // 判断当前类上是否定义了注解<br><code>getAnnotation()</code> // 获取类上定义的注解</p></li></ul><h3 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h3><ul><li>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">   </span><br><span class="line">    list.add(<span class="string">"godql"</span>);</span><br><span class="line">    <span class="comment">// list1.add(20); 错误的</span></span><br><span class="line"></span><br><span class="line">    Class c1 = list.getClass();</span><br><span class="line">    Class c2 = list1.getClass();</span><br><span class="line">   </span><br><span class="line">    System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></span><br><span class="line">    <span class="comment">// 反射的操作都是编译之后的操作(运行时)</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以上说明编译之后集合的泛型是泛型擦除的</span></span><br><span class="line"><span class="comment">     * Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了。</span></span><br><span class="line"><span class="comment">     * 验证: 通过方法的反射来操作，绕过编译 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过动态操作方法的反射得到add方法</span></span><br><span class="line">        Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        <span class="comment">// 方法回调 给list1添加一个int型的，这是在运行时的操作，所以编译器编译时没有泛型检查，所以不会报错</span></span><br><span class="line">        <span class="comment">// 绕过编译操作</span></span><br><span class="line">        m.invoke(list1, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 验证是否有添加进list集合里</span></span><br><span class="line">        System.out.println(list1.size()); </span><br><span class="line">        <span class="comment">// 这时候不能使用foreach遍历，否则集合会认为集合里边全是String类型的值</span></span><br><span class="line">        <span class="comment">// 且有类型转换错误，因为这个集合里面有int类型、String类</span></span><br><span class="line">        System.out.println(list1); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>通用的应用程序</li><li>框架比如：<br>1.Spring 的 Ioc/Di<br>2.SpringMVC 监控 Controller中的注解<br>3.MyBatis 利用反射获取和设置对象值<br>4.Struts2 的 FormBean 和页面之间…<br>5.Hibernate的 find(Class clazz)<br>6.JavaBean和JSP之间调用<br>7.JDBC 的 classForName()</li></ul><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p><a href="https://github.com/GitHubSupervise/JavaSE-Learning-Summary" target="_blank" rel="noopener">GitHub</a></p><p><del>I was within and without.</del></p><p><iframe src="http://www.godql.com/blog/simple/index.html" style="overflow-x:hidden;overflow-y:hidden;border:0xp none #fff;min-height:240px;width:100%" frameborder="0" scrolling="no" allowtransparency="true"></iframe></p><center><font color="grey">请点击↑二维码打赏</font></center><script src="//cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script><div id="player"></div><script>if("none"!==$(".left-col").css("display")){const ap=new APlayer({element:document.getElementById("player"),mutex:!0,theme:"#EBEEDF",order:"random",lrcType:3,fixed:!0});var xhr=new XMLHttpRequest,listid=883067320;xhr.open("get","https://api.i-meto.com/meting/api?server=netease&type=playlist&id="+listid),xhr.onreadystatechange=function(){4===xhr.readyState&&200===xhr.status&&(ap.list.add(JSON.parse(xhr.responseText)),ap.play())},xhr.send()}</script></div></div><div class="copyright"><p><span>Title:</span><a href="/blog/2017/07/07/Core-Java/">深入Java核心</a></p><p><span>Author:</span><a href="/" title="Back to Homepage">Dr.Lester</a></p><p><span>Created:</span>2017-07-07, 23:50:39</p><p><span>Updated:</span>2018-05-26, 03:25:25</p><p><span>Full URL:</span><a class="post-url" href="/blog/2017/07/07/Core-Java/" title="深入Java核心">http://GitHubSupervise.io/blog/2017/07/07/Core-Java/</a></p><p><span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.</p></div><nav id="article-nav"><div id="article-nav-older" class="article-nav-title"><a href="/blog/2017/07/03/Connect the inner and outer net/">外网远程桌面连接内网服务器教程(超详细)</a></div></nav></article><div id="toc" class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载"><span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例说明"><span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class对象"><span class="toc-text">Class对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的利与弊"><span class="toc-text">反射机制的利与弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的相关操作"><span class="toc-text">反射机制的相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建实例"><span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态操作属性"><span class="toc-text">动态操作属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态操作方法"><span class="toc-text">动态操作方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态操作构造方法"><span class="toc-text">动态操作构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class中的一些API"><span class="toc-text">Class中的一些API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过反射了解集合泛型的本质"><span class="toc-text">通过反射了解集合泛型的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码下载"><span class="toc-text">源码下载</span></a></li></ol></li></ol></div><style>.left-col .switch-area,.left-col .switch-btn{display:none}.toc-level-6 i,.toc-level-6 ol{display:none!important}</style><input type="button" id="tocButton" value="Hide" title="Show or Hide Table of Contents"><script>yiliaConfig.toc=["Hide","Show",!0],$(".left-col").is(":hidden")&&$("#tocButton").attr("value",yiliaConfig.toc[1]);</script><div class="share"><div class="social_share"><ul id="social_list" class="social_icon_list"></ul></div><div id="modal-container"><div class="modal-background"><div class="modal"><h2>Copy Link !</h2><p id="link"></p><svg class="modal-svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" preserveaspectratio="none"><rect x="0" y="0" fill="none" width="360" height="162" rx="3" ry="3"></rect></svg></div></div></div><script src="/pages/share/qrcode.min.js"></script><script>var title="深入Java核心",url=window.location.href,author="Dr.Lester",img="http://GitHubSupervise.io/blog/img/Dr.Lester.png",config=[{name:"facebook",set:!0,api:`https://www.facebook.com/sharer/sharer.php?u=${encodeURI(url)}`,title:"Share this article on Facebook",icon:"icon-facebook"},{name:"wechat",set:!0,api:"weixin://",icon:"icon-wechat"},{name:"twitter",set:!0,api:`https://twitter.com/intent/tweet?source=webclient&amp;original_referer=${encodeURI(url)}&amp;text=${encodeURI(title)}&amp;url=${encodeURI(url)}&amp;related=${encodeURI(author)}&amp;via=${encodeURI(author)}`,title:"Share this article on Twitter",icon:"icon-twitter"},{name:"weibo",set:!0,api:`http://v.t.sina.com.cn/share/share.php?url=${encodeURI(url)}&amp;title=${encodeURI(title)}&amp;content=utf8&amp;pic=${encodeURI(img)}`,title:"Share this article on Weibo",icon:"icon-weibo"},{name:"qq",set:!0,api:`http://connect.qq.com/widget/shareqq/index.html?url=${encodeURI(url)}&amp;title=${encodeURI(title)}&amp;pics=${encodeURI(img)}`,title:"Share this article on QQ",icon:"icon-qq"},{name:"qzone",set:!0,api:`http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=${encodeURI(url)}&amp;title=${encodeURI(title)}&amp;pics=${encodeURI(img)}`,title:"Share this article on Qzone",icon:"icon-CN_tencentqzone"},{name:"douban",set:!0,api:`http://www.douban.com/recommend/?url=${encodeURI(url)}&amp;title=${encodeURI(title)}&amp;image=${encodeURI(img)}`,title:"Share this article on Douban",icon:"icon-douban"},{name:"youdao",set:!0,api:`http://note.youdao.com/memory/?title=${encodeURI(title)}&amp;pic=${encodeURI(img)}&amp;url=${encodeURI(url)}`,title:"Share this article on YoudaoNote",icon:"icon-youdaoyunbiji"},{name:"google",set:!0,api:`https://plus.google.com/share?url=${encodeURI(url)}`,title:"Share this article on Google+",icon:"icon-googleplus"},{name:"linkedin",set:!0,api:`https://www.linkedin.com/shareArticle?title=${encodeURI(title)}&amp;url=${encodeURI(url)}`,title:"Share this article on LinkedIn",icon:"icon-linkedin"},{name:"copy",set:!0,title:"Copy the link of this article",icon:"icon-link"},{name:"mail",set:!0,api:`mailto:?subject=${encodeURI(title)}&quot;&amp;body=permalink:${encodeURI(url)}`,title:"Share this article by email",icon:"icon-email"}];var ul=document.getElementById('social_list');config.forEach(function(e){if(JSON.stringify(e)!=='{}'&&e.name&&e.set){let li=document.createElement('li');li.setAttribute('class',`li_item link_${e.name}`);switch(e.name){case'wechat':{li.innerHTML=`<a class="item"href="${e.api}"><i class="iconfont ${e.icon}"></i><div id="qrcode"></div></a>`;break}case'copy':{li.innerHTML=`<span id="copyBtn"class="item"title="${e.title}"><i class="iconfont ${e.icon}"></i><span class="social_name">Copy link</span><textarea id="selection" style="display: none">${url}</textarea></span>`;break}default:{li.innerHTML=`<a class='item'href="${e.api}"rel="nofollow"target="_blank"title='${e.title}'><i class="iconfont ${e.icon}"></i><span class="social_name">${e.name==='qq'?'QQ':e.name}</span></a>`}}ul.appendChild(li)}});document.getElementById('copyBtn').onclick=function(){var input=document.createElement("input");input.setAttribute("readonly","readonly");input.setAttribute("value",url);document.body.appendChild(input);if(!!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)){input.setSelectionRange(0,input.value.length);document.getElementById('link').textContent = url}else{document.getElementById("selection").select()}document.execCommand("copy")||(document.getElementById("link").textContent="Failed！");document.getElementById("modal-container").setAttribute("class","sketch");document.body.removeChild(input)};document.getElementById('copyBtn').oncopy=function(event){if(!-[1,]){if(window.clipboardData){window.clipboardData.setData('Text',url);document.getElementById('link').textContent=window.clipboardData.getData('Text')}}else{event.preventDefault();if(event.clipboardData){event.clipboardData.setData('text/plain',url);document.getElementById('link').textContent=event.clipboardData.getData('text')}}};document.getElementById('modal-container').onclick=function hideModal(){document.getElementById('modal-container').setAttribute('class','sketch out')};document.onload=(function genQRCode(url){return new QRCode('qrcode',{text:url,width:128,height:128,colorDark:'#666',colorLight:'#fff',correctLevel:QRCode.CorrectLevel.M})})(`${encodeURI(url)}#.WthZlpz1y-Y.wechat`)</script></div><section id="comments" style="margin:2em;padding:2em;background:rgba(255,255,255,.5)"><div id="vcomment" class="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomment",notify:"",verify:"",app_id:"oMPq2yvB2hlGuTIz8uJs6aAy-gzGzoHsz",app_key:"UjYvIPBXXg99EpX68PS3Q8Yb",placeholder:"ヾ(≧▽≦*)o来啊，快活啊！",avatar:"identicon",avatar_cdn:"https://s.gravatar.com/avatar/29c7f03a8ce167219c7a6377d9944107?s=80"});</script></section><div class="scroll" id="post-nav-button"><a href="/" title="Back to Homepage"><i class="fa fa-home"></i></a> <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a> <a href="/blog/2017/07/03/Connect the inner and outer net/" title="Next: 外网远程桌面连接内网服务器教程(超详细)"><i class="fa fa-angle-right"></i></a></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2017/07/07/Core-Java/">深入Java核心</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/07/03/Connect the inner and outer net/">外网远程桌面连接内网服务器教程(超详细)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/06/03/Intellij_IDEA_Integration_MyBatis/">Intellij IDEA 2017集成MyBatis三剑客</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/05/17/Precision/">Java数值避免浮点型计算丢失精度问题</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/04/16/javaHighConcurrencyOne/">Java高并发秒杀系统API</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/04/01/sshIntegration/">SSH2(Struts2,Spring4,Hibernate5)整合的意义及其精髓</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/17/IOC-AOP/">深入理解IOC与AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/16/Execution_of_work/">《番茄工作法图解》思维导图读书笔记分享</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/04/Chrome/">非常完整的Chrome浏览器客户端调试大全</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/01/02/Awesome-java-cn/">Java资源大全中文版</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/01/02/professional-programmer/">各种优秀资料、神器及框架</a></li></ul><script></script></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"><i class="fa fa-copyright"></i> 2017- 2018 Dr.Lester</div><div class="footer-right"><img src="/img/icp_min.png"><a href="http://www.miitbeian.gov.cn/">粤ICP备17006987号-1</a></div></div><div class="visit"><span id="busuanzi_container_site_pv" style="display:none"><span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span></span></span> <span>|</span> <span id="busuanzi_container_page_pv" style="display:none"><span id="page-visit" title="Page Hits"><i class="fa fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span></span></span></div></div></footer></div><script type="application/javascript">function hideLeftCol(){hide?($(".left-col").width(leftWidth),$(".left-col .intrude-less").css("display",""),$("#tocButton").css("display",""),"block"===$("#switch-btn").css("display")&&"block"===$("#switch-area").css("display")||$("#toc").slideDown(320),$(".hide-left-col").css("left",leftWidth).html('<i class="fa fa-angle-double-left"></i>'),$(".mid-col").css("left",leftWidth),$("#post-nav-button").css("left",leftWidth),$("#post-nav-button > a:nth-child(2)").css("display","block"),hide=!1):($(".left-col").width(0),$(".left-col .intrude-less").css("display","none"),$("#toc").css("display","none"),$("#tocButton").css("display","none"),$(".hide-left-col").css("left",0).html('<i class="fa fa-angle-double-right"></i>'),$(".mid-col").css("left",0),$("#post-nav-button").css("left",0),$("#post-nav-button > a:nth-child(2)").css("display","none"),$(".post-list").is(":visible")&&($("#post-nav-button .fa-bars,#post-nav-button .fa-times").toggle(),$(".post-list").toggle()),hide=!0)}var hide=!1,leftWidth=300;$(".hide-left-col").click(function(){hideLeftCol()});</script><script data-main="/blog/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],processEscapes:!0,skipTags:["script","noscript","style","textarea","pre","code"]}}),MathJax.Hub.Queue(function(){var a,e=MathJax.Hub.getAllJax();for(a=0;a<e.length;a+=1)e[a].SourceElement().parentNode.className+=" has-jax"});</script><script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="scroll" id="scroll"><a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a> <a href="#comments" title="Comments"><i class="fa fa-comments-o"></i></a> <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a></div><script>var oOpenInNew={post:".copyright a[href]",socail:".social a"};for(var x in oOpenInNew)$(oOpenInNew[x]).attr("target","_blank");</script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))});</script><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>AOS.init({easing:"ease-out-back",once:!0});</script><script src="/blog/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"live2d-widget-model-izumi"},display:{position:"right",width:100,height:200,hOffset:-50,vOffset:-85},mobile:{show:!1},react:{opacityDefault:.9,opacityOnHover:.3},pluginJsPath:"lib/",pluginModelPath:"assets/"});</script></body>